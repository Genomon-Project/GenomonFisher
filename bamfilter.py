#!/usr/local/package/python2.7/2.7.2/bin/python
"""

This is a template of Python main module.


"""

import sys
import os
import re
from datetime import datetime
import argparse
import logging
import pysam

#
# Global
#
global myself
myself = None


# CIGAR ID
BAM_CMATCH      = 0 # M
BAM_CINS        = 1 # I
BAM_CDEL        = 2 # D
BAM_CREF_SKIP   = 3 # N
BAM_CSOFT_CLIP  = 4 # S
BAM_CHARD_CLIP  = 5 # H
BAM_CPAD        = 6 # P
BAM_CEQUAL      = 7 # =
BAM_CDIFF       = 8 # X

#
# class definitions
#
class AutoVivification(dict):
    """Implementation of perl's autovivification feature."""
    def __getitem__(self, item):
        try:
            return dict.__getitem__(self, item)
        except KeyError:
            value = self[item] = type(self)()
        return value


#
# Subroutines
#

############################################################
def PrintHeader( myself, arg ):
    now = datetime.now()

    logging.info( '#' * 84 )
    logging.info( '# Summary' )
    logging.info( '# Generated by {my}'.format( my = myself ) )
    logging.info( '# %(y)d.%(m)d.%(d)d.%(h)d:%(m)d' % { 'y': now.year, 'm': now.month, 'd': now.day, 'h': now.hour, 'm': now.minute } )
    logging.info( '#' * 84 + '' )
    logging.info( "bam: {0}".format( arg.bam ) )
    logging.info( "out_bam: {0}".format( arg.out_bam ) )
    logging.info( "reference fastq: {0}".format( arg.ref_fa ) )
    logging.info( "max_indel: {0}".format( arg.max_indel ) )
    logging.info( "max_distance: {0}".format( arg.max_distance ) )
    logging.info( "map_quality: {0}".format( arg.map_quality ) )
    logging.info( '-' * 84 + '' )


############################################################
def construct_arguments( ):
    """
    Call argparse and create argument object

    """

    parser = argparse.ArgumentParser( description = "Filter bam file" )

    #
    # Positional arguments
    #
    parser.add_argument( "bam",    metavar = '[BAM file]', help = "BAM file for fisher exact ",   type = str )
    parser.add_argument( "out_bam", metavar = '[BAM file]', help = "Filtered BAM file for output", type = str )

    #
    # Optional arguments
    #
    parser.add_argument( '-r', '--ref_fa',    help = "Reference FASTA file", type = str )
    parser.add_argument( '-n', '--max_indel', help = "Threshold number of deletions and insertions [2]",
                                              type = int, default = 2 )
    parser.add_argument( '-d', '--max_distance', help = "Distance value [5]", type = int, default = 5 )
    parser.add_argument( '-m', '--map_quality', help = "Map quality threshold [30]", type = int, default = 30 )


    #
    # Log settings
    #
    parser.add_argument( '-g', '--log_file',  help = "Log file name", type = str, default = None )
    parser.add_argument( '-l', '--log_level', help = "Logging level", type = str, default = 'DEBUG' )

    return parser

############################################################
def FilterBam(
        in_bam,
        out_bam,
        max_indel,
        max_distance,
        map_quality
        ):
    """
    Filter bam and save in bam file

    """

    try:
        if not os.path.exists( "{file}.bai".format( file = in_bam ) ):
            pysam.index( in_bam )

        samfile = pysam.Samfile( in_bam, "rb" )

        #
        # 1. Get header
        #
        header = samfile.header
        outbam = pysam.Samfile( out_bam, "wb", header=header )

        #
        # 2. Read sam/bam file and create filtered reads
        #

        # A. Get edit distance to the reference
        # B. Get the number of deletions and insertions.
        # C. Check the sum of deletions and insertions is less than max_indel ( default: 2 ).
        # D. If C. is met and ( the edit distance - bases of deletion and insertions < max_distance )
        #   save the read.
        #
        logging.info( "Fetch reads and filter" )
        for read in samfile.fetch():

            if read.mapq < map_quality:
                next

            tagNM = 0
            if read.tags:
                for tag, value in read.tags:
                    if tag == 'NM':
                        tagNM = value

            size_D = 0
            size_I = 0
            num_del = 0
            num_ins = 0
            if read.cigar:
                for cigar, value in read.cigar:
                    if BAM_CDEL == cigar:
                        num_del += 1
                        if ( not size_D or size_D < value ):
                            size_D = value

                    elif BAM_CINS == cigar :
                        num_ins += 1
                        if ( not size_I or size_I < value ):
                            size_I = value

                if num_del + num_ins < max_indel:
                    if tagNM - size_D - size_I < max_distance:
                        outbam.write( read )

        outbam.close()
        samfile.close()

    except IOError as (errno, strerror):
        logging.error( "main: I/O error({0}): {1}".format(errno, strerror) )

    except ValueError:
        logging.error( "main: ValueError" )

    except Exception as e:
        exc_type, exc_obj, exc_tb = sys.exc_info()
        fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
        logging.error("{0}: {1}:{2}".format( exc_type, fname, exc_tb.tb_lineno) )


############################################################
#
# Main
#
def main():  
    try:
        #
        # Argument parse
        #
        argvs = sys.argv
        myself = argvs[ 0 ]
        argc = len(argvs)

        arg_parser = construct_arguments()

        if argc < 2:
            arg_parser.print_help()
            sys.exit(1)
        
        arg = arg_parser.parse_args()

        #
        # logging setup
        #
        # Level     function            value    description
        # CRITICAL  logging.critical()  50      Output only critical errors
        # ERROR     logging.error()     40      Output errors
        # WARNING   logging.warning()   30      Output warnings
        # INFO      logging.info()      20      Output information
        # DEBUG     logging.debug()     10      Output debug information
        # NOTSET                        0       Output all
        #
        level = logging.getLevelName( arg.log_level )

        if arg.log_file:
            logging.basicConfig( filename   = arg.log_file,
                                 level      = level,
                                 format     = '%(asctime)s %(message)s',
                                 datefmt    ='%m/%d/%Y %I:%M:%S%p' )
        else:
            logging.basicConfig( level      = level,
                                 format     = '%(asctime)s %(message)s',
                                 datefmt    ='%m/%d/%Y %I:%M:%S%p' )

        #
        # Print header
        #
        PrintHeader( myself, arg )
        
        #
        # Read bam file
        #
        logging.info( "Read bam/sam file." )

        if ( not os.path.exists( arg.bam ) ):
            logging.error( "Input file: {file} not found.".format( file = arg.bam ) )
            raise

        FilterBam( arg.bam, arg.out_bam, arg.max_indel, arg.max_distance, arg.map_quality )

    except IOError as (errno, strerror):
        logging.error( "main: I/O error({0}): {1}".format(errno, strerror) )

    except ValueError:
        logging.error( "main: ValueError" )

    except Exception as e:
        exc_type, exc_obj, exc_tb = sys.exc_info()
        fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
        logging.error("{0}: {1}:{2}".format( exc_type, fname, exc_tb.tb_lineno) )

    return 0


################################################################################
if __name__ == "__main__":
    main()

